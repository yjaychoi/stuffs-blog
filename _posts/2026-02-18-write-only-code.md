---
layout: post
post_uid: 2026-02-18-write-only-code
slug: write-only-code
title: "쓰기 전용 코드 - Joseph Ruscio, Heavybit"
date: 2026-02-18 00:00:02 +0900
tags: [거버넌스, SDLC]
summary: "AI로 인해 발생하는 '쓰기 전용 코드(write-only code)'. 앞으로의 엔지니어링은 '라인별 코드리뷰'를 벗어난 '시스템적인 신뢰, 보호 장치, 리스크 관리'로 옮겨가고 있다."
featured: false
comments: true
---

<div class="info-box">
  <ul>
    <li>원글: <a href="https://www.heavybit.com/library/article/write-only-code">https://www.heavybit.com/library/article/write-only-code</a></li>
    <li>원작자 Joseph Ruscio는 Heavybit의 제너럴 파트너로, 학계, 스타트업, 엔터프라이즈 소프트웨어 분야에서 20년 이상 경험을 쌓았다. 이전에는 Librato를 공동 설립하고 CTO로 회사를 이끌었으며, 인수 이후 SolarWinds에서 클라우드 제품 리더십을 맡았다가 2018년에 Heavybit에 합류했다.</li>
    <li>옮긴이: 검수가 전혀 안된 AI 코드를 던져줘서 당황스러웠던 적이 벌써 여러번이다. 본업에 AI 코딩을 활용한지 얼마 되지도 않았다. 오픈소스에서도 논란이 되고 있는 문제인 만큼, 시니어의 입장에서 생각해볼 계기를 주는 글이다.</li>
  </ul>
</div>

**아래 모든 내용은 엔터프라이즈 소프트웨어의 관점이다. 대규모 매출을 발생시키는, 전통적으로 수백·수천 명 규모의 엔지니어링 조직이 구축하고 운영해 온 소프트웨어 시스템을 말한다. 다른 유형의 소프트웨어에도 시사점이 있지만, 이는 다음 기회에 따로 다루도록 하겠다.**

이미 6개월 전만 해도, 실제 프로덕션 코드의 대부분을 앞으로 AI가 작성하리란 것은 분명했다. LLM은 개발자의 생산성을 막대하게 향상시키고 있고, 기획자의 의도를 사람이 한땀한땀 코드로 번역하는 일의 가치는 빠르게 떨어지고 있다. '일'이 무엇인지에 대한 추상화가 새로 이루어지고, 개발자의 일상이 획기적으로 바뀌더라도, 엔터프라이즈 소프트웨어를 구축하고 운영할 사람들은 계속 필요할 것이다.

미처 생각 못했던 점은, 미래의 '일'에서 코드를 읽고 리뷰하는 비중이 얼마나 적을지였다.

좋든 나쁘든 우리는 미래를 향해 돌진하고 있다. 실제 프로덕션 코드의 대부분을, 갈수록 더 많은 비중을, 미래에는 사람이 전혀 읽지 않을 거라고 확신한다. 훑어보지도 않고, 리뷰하지도 않고, 수정하지도 않는 코드 말이다. 이러한 코드를 <u>쓰기 전용 코드(Write-Only Code)</u>라 부르며, 우리 업계에 미칠 영향에 대해 긴 시간 고민해 왔다. (명칭을 함께 고민해 준 [LocalStack](https://www.heavybit.com/portfolio/localstack)의 [Waldemar Hummer](https://www.linkedin.com/in/whummer)에게 감사를 전한다.)

이미 많은 엔터프라이즈 조직에서 AI가 코드를 작성하지만, 대부분은 아직 'AI 페어 프로그래밍' 같은 구성을 의미한다. 사람은 작업을 '일감'으로 분해해 에이전트에게 넘기고, 돌아오는 PR을 리뷰하고, 수정해주고, 필요하면 다시 프롬프팅 하고, 결과물이 만족스러울 때까지 과정을 반복한다. 2025년 말 전에 출시된 AI 모델을 사용하면서, 프로덕션 코드를 안정적으로 배포하기 위한 합리적인 해결책이었다. 미묘하지만 중요한 점은, 이러면 사람의 검수가 필수로 요구됨에 따라 과거의 소프트웨어 개발 생명주기(SDLC) 또한 함께 보전된다는 것이다. 프로덕션에 반영되는 모든 변경사항은 여전히 '휴먼 리뷰'라는 주요 병목을 통과해야 하기 때문이다.

하지만 '휴먼 리뷰'의 병목은 이제 사라지고 있다.

근래 모델 성능의 도약은 전통 SDLC를 떠받치고 있는 핵심 가정들을 깨뜨리는 첫걸음이다. 이제 에이전트들은 보다 고수준(high-level)의, 큼직한 기능 단위까지 처리할 수 있게 되었다. 에이전트가 장시간 동안 계획하고 실행하며 스스로 오류를 수정하는 새로운 기법들이 등장하면서, 에이전트가 만들어 낼 수 있는 실제 소프트웨어의 범위와 복잡성이 얼마나 충격적인지 벌써 증명 중이다. 이러한 작업 방식이 도입된다면, 모든 코드 라인을 사람이 리뷰하기에는 리소스가 턱없이 부족하도록 방대하고 빠른 속도로 소프트웨어가 생산될 것이다.

일부 AI 극단론자들과는 생각이 다르다. '아무도 코드를 읽지 않는다'가 곧바로 '인간이 전혀 개입하지 않는다'는 뜻이라고 생각하지 않는다. 기업에는 여전히 책임성이 필요하다. 시스템, 그리고 해당 시스템의 기술·사업적 결과, 퍼포먼스에 대한 오너십을 가질 사람이 필요하다. 장애에 대응할 사람, 사고가 발생했을 때 궁극적으로 책임을 질 사람이 필요하다. 엔터프라이즈 소프트웨어는 단순 코드 이상의, 수없이 많은 것을 벤더사에게 요구한다.

소프트웨어 엔지니어의 역할은 언제나 같았다. 모호하고 부정확한 자연어로 된 비즈니스 목표를 (대부분) 결정적인 기계 동작으로 변환하는 과정에서 수많은 제약 조건을 조율하는 역할이다. 한층 더 단순화하면 '리스크를 최소화하는 것'이라고 할 수 있겠다. 비즈니스가 경쟁에 필요한 역량을 갖추지 못할 위험을 줄이는 것. 소프트웨어가 작동 안하거나, 확장이 불가능하거나, 비즈니스 목표가 바뀔 때 이에 맞춰 적응하지 못할 위험을 줄이는 것이다. <u>쓰기 전용 코드</u>가 LLM에서 프로덕션으로 곧바로 흘러 들어가는 미래에도 이 역할 자체가 사라지지는 않지만, 인간이 이 역할을 수행하기 위해 필요한 문화, 프로세스, 도구는 근본적인 재고가 필요하다.

## 역사는 반복되지 않지만, 라임을 타듯 운율을 따른다

소프트웨어 개발과 배포·운영의 역사는 하나의 병목을 제거하면 곧바로 다음 병목과 마주하는 일상의 반복이었다. 아마도 역사상 가장 큰 병목인, 사람이 직접 코드를 작성하는 작업을 제거하려는 지금, 이전에 마지막으로 제거했던 병목을 되짚어보고자 한다.

불과 몇 십 년 전만 해도, 새로운 엔터프라이즈 소프트웨어를 프로덕션에서 운영하기 위한 실질적인 병목은 코드 작성이 전혀 아니었다. 그 시절의 병목은 하드웨어였다. 서버를 구매하고, 배송을 기다리고, 랙에 장착하고, 네트워킹을 구성한 뒤, 몇 달이 지나서야 비로소 무언가를 프로덕션에 올릴 수 있었다. 2000년대 중반에 등장한 지속적 배포(CD, Continuous Delivery) 방식과 온디맨드 가상 컴퓨팅(역주: 하이퍼스케일러)의 결합은 그 제약을 무너뜨렸다.

이후에 등장한 것은 프로덕션 환경을 대하는 태도 자체를 근본적으로 바꾸어 버린 새로운 도구와 관행의 연속이었다. 데브옵스(DevOps)의 "서버는 애완동물이 아닌 가축"은 단순한 슬로건이 아니라, 기대치를 완전히 바꿔놓는 사건이었다. 프로덕션 서버는 더 이상 소중히 다뤄지거나 이름을 붙여 애지중지 관리되는 대상이 아니게 되었다. 서버를 사람이 접속하는 용도가 아니고 프로그램적으로 찍어내듯 생성한다는 생각은 한때는 터무니없게 여겨졌다. 반대로 오늘날에는 고성과 팀에서 누군가 프로덕션 기기에 원격으로 접속하면, 해당 기기는 오염된 것으로 간주되고, 깨끗한 새 인스턴스로 교체되도록 스케줄링 된다.

이러한 변화와 함께 병목 지점은 '개발자 속도(developer velocity)'로 옮겨 갔다. 인프라를 필요할 때마다 프로비저닝할 수 있고, 작은 변경 사항도 작업 즉시 프로덕션까지 배포할 수 있게 되자, 인간 개발자가 비즈니스 요구사항을 얼마나 빠르게 소프트웨어로 구현할 수 있느냐가 새로운 제약 요인이 되었다. 이는 새로운 생산성의 물결을 일으켰고, 개발자가 《[The New Kingmakers](https://www.oreilly.com/library/view/the-new-kingmakers/9781449368036)》 (새로운 킹메이커)로 불리게 된 계기라고 생각한다.

이런 현실은 내가 [마지막으로 창업했던 스타트업](https://www.heavybit.com/portfolio/librato)에서 '어떻게 일할 것인가'에 대한 거의 모든 결정에 영향을 미쳤다. SDLC의 모든 변경사항은 먼저 개발자 속도의 관점에서 평가해야 한다고 병적으로 고집했다. 개발자 속도를 안전하게 높여 주는 변경은 사실상 의무 사항이었다. 개발자를 느려지게 만드는 변경은 철저한 검토 대상이었고, 완전히 거부되지 않더라도 최소한 그 영향을 줄이도록 조정했다. 시간이 지나면서, 팀원들은 이 휴리스틱을 반은 농담처럼 "Ruscio의 법칙"이라고 부르게 되었다.

우리가 단순한 경험칙 정도로 여겼던 것이, 이제는 더 이상 '엘리트 조직을 위한 최적화'가 아닌 '생존을 위한 필수 조건'으로 급속히 바뀌어 가고 있다.

## 리뷰하지 않고 신뢰하기

현대 소프트웨어 역사의 대부분에서, 사람에 의한 코드 리뷰는 프로덕션 시스템에 대한 신뢰를 보장하는 최후의 보루였다. 테스트는 불완전할 수 있고, 모니터링은 미흡할 수 있으며, 숨어있는 버그는 찾기 어렵지만, 결국 코드를 작성하고 검토하는 숙련된 엔지니어들은 코드가 어떻게 작동할지 추론이 가능하다. <u>쓰기 전용 코드</u>는 이 전제를 대대적으로 무너뜨린다. 사람이 읽지 않을 코드를 배포한다면, 신뢰성을 확보할 다른 방법이 필요하다.

마치 이제는 사람이 개별 프로덕션 서버에 직접 셸로 접속하지 않는 것처럼, 읽지 않는 코드에 대해서도 비슷한 관행이 자리 잡게 될 것이라고 생각한다. 시간이 지날수록 '안심하기 위해 읽어봐야 하는 코드'는 생성 파이프라인에 스멜로 치부하거나, 정말로 미션 크리티컬한 하위 시스템에만 허용되는 명시적이고 비용이 큰 트레이드오프로 취급하게 될 것이다. 이런 변화의 자연스러운 결과로, 테스트 커버리지처럼 추적되는 '코드 읽기 커버리지' 같은 지표가 등장할 것이다. 실제로 프로덕션 코드 중에 어느 정도 비율이 사람이 직접 읽어본 코드인지, 이를 한편으로는 안전 시그널로, 또 한편으로는 팀이 의도적으로 감소시키며 어떤 점으로 수렴하게 만들고자 하는 지표로 활용할 수 있으리라.

실용적인 조직이라면 <u>쓰기 전용 코드</u>를 모든 곳에 한꺼번에 도입하지는 않을 것이다. 어디에서부터 안전하게 시작할 수 있는지, 어디에서 기존의 사람에 의한 리뷰가 계속 유지되어야 하는지를 식별해야 한다. 의도치 않은 동작이 발견되거나 격리되기 전에 얼마나 멀리까지 영향을 미칠 수 있는지를 나타내는 '슬롭(Slop) 폭발 반경'을 이해하고 통제하는 것은, 팀이 반드시 길러야 할 핵심 역량일 것이다. 방법론과 기술이 성숙해지고 자동화로부터 얻을 수 있는 보장 수준이 향상될수록, 읽지 않는 코드의 범위는 넓어지고 수동 리뷰의 범위는 줄어든다.

엔지니어들에게 중요한 질문은 이 변화가 일어날지의 여부가 아니라, 신뢰의 기반으로서 수동 코딩과 리뷰를 대신해 어떤 기본 요소가 자리 잡게 될 것인가이다.

## 엔지니어란 직업은 어떻게 변하는가

'AI 페어 프로그래머'의 이야기에서 인간 엔지니어는 여전히 주로 코드의 작성자이자 리뷰어다. 반면 '<u>쓰기 전용 코드</u>'의 이야기에서는 같은 엔지니어가 시스템 설계자, 제약 조건 작성자, 그리고 트레이드오프 관리자로 변한다.

구현체를 다듬기보다 의도를 구체화하기 위해 더 많은 시간을 쏟는다. 인터페이스, 불변 조건, 실패 유형, 반드시 성립해야 하는 조건들에 집착한다. 무엇이 여전히 사람의 검토를 필요로 하는지, 무엇이 명시적으로 그렇지 않은지를 결정한다. '검증하지 않고 배포'가 무모한 행동이 아니라 경쟁 우위가 되도록 만드는 툴 스택에 투자한다. 위험을 최소화한다.

또한 SDLC가 겉으로 보이는 인풋과 산출물은 같아 보여도, 내부적으로는 재구성되고 있다는 사실을 받아들인다. 고객은 여전히 소프트웨어를 요청하고 작동하는 소프트웨어를 받지만, 내부 공정 과정은 근본적으로 달라졌다. 얼마나 달라졌는지가 승자를 가릴 것이다.

간과해서는 안 되는 심리적 전환도 있다. 엔지니어들은 오랫동안 자신들이 만들어 배포하는 코드를 정교하게 빚어내고 깊이 이해하는 데 자부심을 가져왔다. 예를 들어 《[Beautiful Code](https://www.oreilly.com/library/view/beautiful-code/9780596510046)》 (아름다운 코드)를 기리는 내용이 전부인 책도 있을 정도다. 그러나 <u>쓰기 전용 코드</u>의 시대에는, 코드 한 줄 한 줄을 이해하지 않더라도 시스템이 올바르게 동작하도록 만드는 능력으로 자부심이 옮겨 간다. '나는 코드를 쓴다'는 '나는 소프트웨어를 만든다'로 바뀐다. 사람은 여전히 결과에 대한 책임을 지겠지만, 갈수록 코드를 읽지 않고도 확신을 얻는 방법을 찾아나설 것이다.

## 끝맺으며

<u>쓰기 전용 코드</u>는 우리가 무엇을 원해야 하는지에 대한 예측이 아니다. 소프트웨어 생산의 규모가 인간의 집중력이 허용하는 수준을 넘어설 때 발생하는 현상을 설명하기 위함이다. '사람이 코딩에 개입해야 하는지'는 핵심이 아니다. 핵심은 '더 이상 완전히 들여다볼 수 없는 시스템의 동작에 책임을 질 것인지'이다. 이런 상황은 이미 여러 번 겪었을 것이다. 병목이 하나 해소될 때마다, 그 자리를 꿰차는 새로운 병목을 중심으로 업계는 재편되어 왔다.

검수하지 않은 코드를 규율의 실패로 취급하는 것은 실수다. 이는 오히려 규율 자체를 바꿔야 한다는 신호다. 인간에 의한 리뷰가 사라지는 것은 그것이 중요하지 않아서가 아니라, 더 이상 맞닥뜨린 문제의 규모와 형태에 맞지 않기 때문이다. 이 전환에서 성공할 조직은 익숙한 의식상의 절차를 끝까지 붙잡고 있는 조직이 아니라, 신뢰·책임·통제를 위한 새로운 기본 요소에 가장 먼저 투자하는 조직이다. 변화를 거부한다고 해서 안전하지 않다. 오히려 변화가 의도성 없이, 압박 속에서, 우연히 일어나도록 만들 뿐이다.

인간 엔지니어의 역할이 단순히 코드 입력에 불과했던 적은 결코 없다. 모호성, 제약사항, 변화 속에서 위험을 줄이는 것이 바로 엔지니어의 역할이었다. 그 책임은 <u>쓰기 전용 코드</u>의 세계에서도 사라지지 않을 뿐 아니라, 오히려 더욱 확장된다.

앞으로 소프트웨어 엔지니어링의 성숙도는 우리가 내보낸 코드를 얼마나 세심하게 검토했는지가 아니라, 프로덕션 환경에서 돌아가는 코드를 사람이 전혀 읽지 않는다 해도 시스템이 올바르고 견고하며 책임 있게 동작하도록 얼마나 잘 설계되었는가에 의해 판가름될 것이다.
