name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_ref:
        description: "Commit SHA to deploy (must be reachable from main)"
        required: false
        type: string

permissions:
  actions: read
  contents: read
  pages: write
  id-token: write

concurrency:
  group: github-pages
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    env:
      TZ: UTC
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve deploy target
        id: resolve
        run: |
          git fetch origin main --depth=400
          candidate="${{ github.event.inputs.deploy_ref }}"
          if [ -z "$candidate" ]; then
            candidate="${GITHUB_SHA}"
          fi

          if ! [[ "$candidate" =~ ^[0-9a-fA-F]{40}$ ]]; then
            echo "deploy_ref must be a full 40-char SHA"
            exit 1
          fi

          if ! git merge-base --is-ancestor "$candidate" origin/main; then
            echo "Target commit is not reachable from origin/main"
            exit 1
          fi

          echo "deploy_sha=$candidate" >> "$GITHUB_OUTPUT"

      - name: Checkout deploy target
        run: git checkout --detach "${{ steps.resolve.outputs.deploy_sha }}"

      - name: Verify CI status on deploy target
        uses: actions/github-script@v7
        env:
          DEPLOY_SHA: ${{ steps.resolve.outputs.deploy_sha }}
        with:
          script: |
            const sha = process.env.DEPLOY_SHA;
            const maxAttempts = 90; // 30 minutes at 20s intervals
            const intervalMs = 20_000;
            const workflowId = "ci.yml";

            for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                head_sha: sha,
                per_page: 20
              });

              const runs = data.workflow_runs
                .filter((run) => run.head_sha === sha)
                .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());

              if (!runs.length) {
                core.info(`No CI workflow runs found for ${sha} yet (attempt ${attempt}/${maxAttempts}).`);
              } else {
                const latest = runs[0];
                core.info(
                  `CI workflow run ${latest.id} for ${sha}: status='${latest.status}' conclusion='${latest.conclusion || "n/a"}' (attempt ${attempt}/${maxAttempts}).`
                );

                if (latest.status === "completed") {
                  if (latest.conclusion === "success") {
                    return;
                  }

                  core.setFailed(
                    `CI workflow ${workflowId} for ${sha} completed with conclusion '${latest.conclusion}'. ${latest.html_url}`
                  );
                  return;
                }
              }

              if (attempt < maxAttempts) {
                await new Promise((resolve) => setTimeout(resolve, intervalMs));
              }
            }

            core.setFailed(
              `Timed out waiting for CI workflow ${workflowId} to complete successfully for ${sha} after ${Math.floor(
                (maxAttempts * intervalMs) / 60_000
              )} minutes.`
            );

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: true

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: npm

      - name: Enforce lockfiles and install dependencies
        run: |
          bundle config set frozen true
          bundle install --jobs 4 --retry 3
          npm ci

      - name: Derive deterministic build metadata
        run: |
          echo "SOURCE_DATE_EPOCH=$(git show -s --format=%ct ${{ steps.resolve.outputs.deploy_sha }})" >> "$GITHUB_ENV"
          echo "DEPLOY_SHA=${{ steps.resolve.outputs.deploy_sha }}" >> "$GITHUB_ENV"

      - name: Generate build metadata
        run: npm run build:meta

      - name: Build site
        run: bundle exec jekyll build

      - name: Contract tests
        run: npx vitest run tests/contracts

      - name: Asset size limits
        run: npx size-limit --config size-limit.config.cjs

      - name: Install Playwright browser
        run: npx playwright install --with-deps chromium

      - name: End-to-end tests
        run: npx playwright test

      - name: Configure Pages
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: _site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Post-deploy smoke checks with retry/backoff
        env:
          BASE_URL: ${{ steps.deployment.outputs.page_url }}
        run: |
          set -euo pipefail

          if [ -z "${BASE_URL}" ]; then
            echo "Missing deployment URL"
            exit 1
          fi

          request_ok() {
            url="$1"
            expected_code="$2"
            body_file
            body_file=$(mktemp)
            code=$(curl -sS -o "$body_file" -w '%{http_code}' "$url")
            if [ "$code" != "$expected_code" ]; then
              rm -f "$body_file"
              return 1
            fi
            cat "$body_file"
            rm -f "$body_file"
            return 0
          }

          run_probe_suite() {
            request_ok "${BASE_URL}/" 200 >/tmp/home.html
            request_ok "${BASE_URL}/blog/" 200 >/tmp/blog.html
            request_ok "${BASE_URL}/tags/" 200 >/tmp/tags.html
            request_ok "${BASE_URL}/subscribe/" 200 >/tmp/subscribe.html
            request_ok "${BASE_URL}/subscribe/success/" 200 >/tmp/subscribe_success.html
            request_ok "${BASE_URL}/privacy/" 200 >/tmp/privacy.html
            request_ok "${BASE_URL}/feed.xml" 200 >/tmp/feed.xml
            request_ok "${BASE_URL}/blog/mysql-vector-search/" 200 >/tmp/post.html
            request_ok "${BASE_URL}/blog/page/1/" 200 >/tmp/blog_page_one.html
            request_ok "${BASE_URL}/this-route-should-not-exist/" 404 >/tmp/unknown_404.html

            grep -q "<rss" /tmp/feed.xml
            grep -q "rel=\"canonical\"" /tmp/post.html
            grep -Eq "language-mermaid|mermaid" /tmp/post.html
            grep -q "noindex" /tmp/blog_page_one.html
            grep -q "/blog/" /tmp/blog_page_one.html
            grep -q "404" /tmp/unknown_404.html
          }

          success=0
          for wait_seconds in 0 5 15 30 60 120; do
            if [ "$wait_seconds" -gt 0 ]; then
              sleep "$wait_seconds"
            fi

            if run_probe_suite; then
              success=1
              break
            fi
          done

          if [ "$success" -ne 1 ]; then
            echo "Post-deploy smoke checks failed"
            exit 1
          fi

      - name: Post-deploy browser smoke checks
        env:
          PLAYWRIGHT_BASE_URL: ${{ steps.deployment.outputs.page_url }}
        run: |
          npx playwright test --config playwright.deploy.config.ts --grep @smoke
          npx playwright test --config playwright.deploy.config.ts tests/e2e/no_js.spec.ts
