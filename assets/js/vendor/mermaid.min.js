(function (global) {
  var settings = { theme: "default" };

  function escapeXml(value) {
    return String(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function parseNodeToken(token) {
    var value = (token || "").trim();
    var quoted = value.match(/^([A-Za-z0-9_]+)\s*\[\s*\"(.+)\"\s*\]$/);
    if (quoted) {
      return { id: quoted[1], label: quoted[2] };
    }

    var bracketed = value.match(/^([A-Za-z0-9_]+)\s*\[\s*(.+)\s*\]$/);
    if (bracketed) {
      return { id: bracketed[1], label: bracketed[2] };
    }

    var plain = value.match(/^([A-Za-z0-9_]+)$/);
    if (plain) {
      return { id: plain[1], label: plain[1] };
    }

    return { id: value.replace(/[^A-Za-z0-9_]/g, "") || "node", label: value };
  }

  function parseDiagram(source) {
    var lines = String(source || "")
      .split(/\r?\n/)
      .map(function (line) {
        return line.trim();
      })
      .filter(function (line) {
        return line.length > 0 && !line.startsWith("%%");
      });

    if (lines.length === 0) {
      throw new Error("Empty Mermaid source.");
    }

    var direction = "LR";
    var first = lines[0].match(/^(?:flowchart|graph)\s+([A-Za-z]{2})$/i);
    if (first) {
      direction = first[1].toUpperCase();
      lines = lines.slice(1);
    }

    var nodeById = {};
    var nodeOrder = [];
    var edges = [];

    function registerNode(node) {
      if (!nodeById[node.id]) {
        nodeById[node.id] = { id: node.id, label: node.label || node.id };
        nodeOrder.push(node.id);
      } else if (node.label && node.label !== node.id) {
        nodeById[node.id].label = node.label;
      }
    }

    for (var i = 0; i < lines.length; i += 1) {
      var line = lines[i];
      if (line.indexOf("-->") === -1) {
        continue;
      }

      var segments = line.split("-->");
      if (segments.length < 2) {
        continue;
      }

      var fromNode = parseNodeToken(segments[0]);
      var toNode = parseNodeToken(segments.slice(1).join("-->") || "");
      registerNode(fromNode);
      registerNode(toNode);

      edges.push({ from: fromNode.id, to: toNode.id });
    }

    if (edges.length === 0 || nodeOrder.length === 0) {
      throw new Error("Unsupported Mermaid content.");
    }

    return {
      direction: direction,
      nodes: nodeOrder.map(function (id) {
        return nodeById[id];
      }),
      edges: edges
    };
  }

  function buildLayout(diagram) {
    var isVertical = diagram.direction === "TB" || diagram.direction === "TD" || diagram.direction === "BT";
    var nodeHeight = 54;
    var minWidth = 128;
    var maxWidth = 240;
    var charWidth = 7;
    var gap = isVertical ? 48 : 58;
    var margin = 28;

    var nodes = [];
    var nodeMap = {};
    var cursor = margin;
    var maxNodeWidth = 0;

    for (var i = 0; i < diagram.nodes.length; i += 1) {
      var node = diagram.nodes[i];
      var width = Math.max(minWidth, Math.min(maxWidth, Math.ceil(node.label.length * charWidth + 44)));
      maxNodeWidth = Math.max(maxNodeWidth, width);

      nodes.push({
        id: node.id,
        label: node.label,
        width: width,
        height: nodeHeight,
        x: isVertical ? margin : cursor,
        y: isVertical ? margin + i * (nodeHeight + gap) : margin
      });

      if (!isVertical) {
        cursor += width + gap;
      }
    }

    if (isVertical) {
      for (var n = 0; n < nodes.length; n += 1) {
        nodes[n].x = margin + (maxNodeWidth - nodes[n].width) / 2;
      }
    }

    for (var j = 0; j < nodes.length; j += 1) {
      nodeMap[nodes[j].id] = nodes[j];
    }

    var width = isVertical
      ? margin * 2 + maxNodeWidth
      : margin * 2 + nodes.reduce(function (acc, node) {
          return acc + node.width;
        }, 0) + gap * Math.max(nodes.length - 1, 0);
    var height = isVertical
      ? margin * 2 + nodes.length * nodeHeight + gap * Math.max(nodes.length - 1, 0)
      : margin * 2 + nodeHeight + 90;

    return {
      width: width,
      height: Math.max(height, 180),
      isVertical: isVertical,
      nodes: nodes,
      nodeMap: nodeMap,
      edges: diagram.edges
    };
  }

  function palette() {
    var dark = settings.theme === "dark";
    return {
      canvas: "transparent",
      canvasStroke: "transparent",
      nodeFill: dark ? "#1f242d" : "#fcfaf2",
      nodeStroke: dark ? "#9cde34" : "#6f9020",
      text: dark ? "#edf1f7" : "#242823",
      edge: dark ? "#9cde34" : "#6f9020"
    };
  }

  function edgePath(edge, map, isVertical) {
    var from = map[edge.from];
    var to = map[edge.to];
    if (!from || !to) {
      return "";
    }

    var startX = from.x + from.width / 2;
    var startY = from.y + from.height / 2;
    var endX = to.x + to.width / 2;
    var endY = to.y + to.height / 2;

    if (isVertical) {
      startY = from.y + from.height;
      endY = to.y;
      return "M " + startX + " " + startY + " L " + endX + " " + endY;
    }

    startX = from.x + from.width;
    endX = to.x;
    return "M " + startX + " " + startY + " L " + endX + " " + endY;
  }

  function renderSvg(id, source) {
    var parsed = parseDiagram(source);
    var layout = buildLayout(parsed);
    var colors = palette();

    var nodeMarkup = layout.nodes
      .map(function (node) {
        var cx = node.x + node.width / 2;
        var cy = node.y + node.height / 2;
        return (
          '<g class="mermaid-node">' +
          '<rect x="' +
          node.x +
          '" y="' +
          node.y +
          '" width="' +
          node.width +
          '" height="' +
          node.height +
          '" rx="6" ry="6" fill="' +
          colors.nodeFill +
          '" stroke="' +
          colors.nodeStroke +
          '" stroke-width="1.5" />' +
          '<text x="' +
          cx +
          '" y="' +
          cy +
          '" text-anchor="middle" dominant-baseline="middle" fill="' +
          colors.text +
          '" font-family="Noto Sans KR, system-ui, sans-serif" font-size="14" font-weight="600">' +
          escapeXml(node.label) +
          "</text></g>"
        );
      })
      .join("");

    var edgeMarkup = layout.edges
      .map(function (edge) {
        var path = edgePath(edge, layout.nodeMap, layout.isVertical);
        if (!path) {
          return "";
        }
        return '<path d="' + path + '" stroke="' + colors.edge + '" stroke-width="1.8" fill="none" marker-end="url(#' + id + '-arrow)" />';
      })
      .join("");

    return (
      '<svg xmlns="http://www.w3.org/2000/svg" width="' +
      layout.width +
      '" height="' +
      layout.height +
      '" viewBox="0 0 ' +
      layout.width +
      " " +
      layout.height +
      '" role="img" aria-labelledby="' +
      id +
      '-title">' +
      '<title id="' +
      id +
      '-title">Mermaid diagram</title>' +
      '<defs><marker id="' +
      id +
      '-arrow" markerWidth="10" markerHeight="8" refX="8" refY="4" orient="auto" markerUnits="strokeWidth">' +
      '<path d="M 0 0 L 10 4 L 0 8 z" fill="' +
      colors.edge +
      '" /></marker></defs>' +
      '<rect x="1" y="1" width="' +
      (layout.width - 2) +
      '" height="' +
      (layout.height - 2) +
      '" rx="7" ry="7" fill="' +
      colors.canvas +
      '" stroke="' +
      colors.canvasStroke +
      '" />' +
      '<g class="mermaid-edges">' +
      edgeMarkup +
      '</g><g class="mermaid-nodes">' +
      nodeMarkup +
      "</g></svg>"
    );
  }

  global.mermaid = {
    initialize: function (options) {
      settings = Object.assign({}, settings, options || {});
    },
    render: function (id, source) {
      return new Promise(function (resolve, reject) {
        try {
          resolve({ svg: renderSvg(id, source || "") });
        } catch (error) {
          reject(error);
        }
      });
    }
  };
})(window);
